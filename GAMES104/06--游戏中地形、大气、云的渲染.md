[TOC]

# 六、游戏中地形、大气、云的渲染

## 6.1	地形的几何

### 6.1.1	Heightfield

<img src="AssetMarkdown/image-20230710164528555.png" alt="image-20230710164528555" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230710164711163.png" alt="image-20230710164711163" style="zoom:80%;" />

### 6.1.3	两个优化的准则

1. FOV越窄，三角形划分越密集

<img src="AssetMarkdown/image-20230710165356323.png" alt="image-20230710165356323" style="zoom:80%;" />

2. 和ground truth在屏幕上的误差不要超过一个像素

<img src="AssetMarkdown/image-20230710171620877.png" alt="image-20230710171620877" style="zoom:80%;" />

### 6.1.4	基于三角形的剖分

<img src="AssetMarkdown/image-20230710171859276.png" alt="image-20230710171859276" style="zoom:80%;" />

**T-Junctions**

1. 问题：当两个相邻的三角形在同一个边上，这个三角形没有切分这条边，而相邻三角形切分了(高度会随之变化)，会导致地形上有个裂缝
2. 解决方法：如果发现边上有邻居对相邻边的切分更密集，则当前三角形也需要将该边切分，直到与邻居的切分数相同

<img src="AssetMarkdown/image-20230710172014900.png" alt="image-20230710172014900" style="zoom:80%;" />

### 6.1.5	基于四叉树的切分

<img src="AssetMarkdown/image-20230710172614256.png" alt="image-20230710172614256" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230710172803559.png" alt="image-20230710172803559" style="zoom:80%;" />

解决T-Junctions的问题：**Stitching吸附**

1. 将划分更密集的那个三角形的中心，对齐到更稀疏的三角形上
2. 即划分出了一个面积为0的三角形

<img src="AssetMarkdown/image-20230713102702521.png" alt="image-20230713102702521" style="zoom:80%;" />

### 6.1.6	基于不规则三角形的绘制 TIN

<img src="AssetMarkdown/image-20230713103514295.png" alt="image-20230713103514295" style="zoom:80%;" />

通过顶点简化，减少三角形的数目

优点：

1. 通常情况下，三角形的数目更少

缺点：

1. 地形的三角形难以在渲染的时候调整

### 6.1.7	基于GPU的曲面细分(Tessellation)

DirectX12开始支持Mesh Shader

1. 在给定Mesh Shader之后，Mesh Shader会生成一小块meshlit(一小片顶点&三角形)，顶点&三角形如何插值、如何凸包由shader控制

<img src="AssetMarkdown/image-20230713104436099.png" alt="image-20230713104436099" style="zoom:80%;" />

### 6.1.8	Real-Time Deformable Terrain

<img src="AssetMarkdown/image-20230713105028872.png" alt="image-20230713105028872" style="zoom:80%;" />

如果所有顶点的位置都可以在runtime动态调整，则可以让地形产生动态效果

1. 在人物的周边生成一个terrain deformable的texture，将这上面的脚印记录在texture上
2. 当移动的时候，texture跟着角色走，但是要保持数据一致性
3. 由于地形数据是实时细分出来的，就可以根据texture添加一些offset
4. 还要注意更新地形的碰撞

### 6.1.9	Non-Heightfield Terrain

地形不止有起伏，还有悬崖山洞之类的物体

#### 6.1.9.1	在Terrain中开一个洞

<img src="AssetMarkdown/image-20230713105844108.png" alt="image-20230713105844108" style="zoom:80%;" />

1. 可以在设置顶点位置的时候，判断一下这个顶点是否在洞中
2. 如果在洞中，则将其位置设为NaN
3. GPU在看到位置为NaN的顶点后，不会绘制用到这个顶点的所有物体
4. 然后再通过加一个山洞的模型，避免地形上的zigzag条纹显示出来

#### 6.1.9.2	地形体素化表达

<img src="AssetMarkdown/image-20230713110208576.png" alt="image-20230713110208576" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230713110303928.png" alt="image-20230713110303928" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230713110648064.png" alt="image-20230713110648064" style="zoom:80%;" />

1. 将地形表示为三维空间，三维空间中的每个点存一个权重值，表示这个位置是否有物质、物质的密度
2. 通过Marching Cubes方法，找到等值面，切分立方体，形成一个水密的三角面片集，把形状表达出来

## 6.2	地形的材质

### 6.2.1	Texture Splatting

<img src="AssetMarkdown/image-20230713110922421.png" alt="image-20230713110922421" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230713111446052.png" alt="image-20230713111446052" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230713111410233.png" alt="image-20230713111410233" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230713111837774.png" alt="image-20230713111837774" style="zoom:80%;" />

1. 每个材质存储Base Color、Normal、Roughness、Height四种贴图
2. 再存储一张混合贴图，每个channel表示一种贴图的权重，通过笔刷设置不同材质的权重
3. 在过渡的时候，如果需要混合两种材质，则根据height对权重进行调整，height高的权重下降慢
   1. 缺点：由于是01切换，当相机移动的时候，会有很多抖动，导致分界线过硬
   2. 解决方法：添加一个bias，当两者高度差<bias的时候，用权重进行插值

### 6.2.2	在Texture Array中采样

<img src="AssetMarkdown/image-20230713112037261.png" alt="image-20230713112037261" style="zoom:80%;" />

1. 将地表的多种材质存储为一个数组，每次采样仅会采样其中一个材质
2. 混合的时候，根据位置、权重、index，判断采样哪种材质，采样的权重是但多少

### 6.2.3	Displacement Mapping

<img src="AssetMarkdown/image-20230713112551490.png" alt="image-20230713112551490" style="zoom:80%;" />

### 6.2.4	Expensive Material Blending

1. 每一次进行纹理采样，都需要采样8个点，进行7次插值
2. 一个点有几种材质进行混合，就需要在上述基础上乘几
3. 而这些采样的数据在内存中的不同地方，address的不停跳跃会非常浪费时间
4. 事实上，我们看到的地形仅有地形的一部分，其他部分都会被裁剪掉

<img src="AssetMarkdown/image-20230713113001442.png" alt="image-20230713113001442" style="zoom:80%;" />

### 6.2.5	Virtual Texture

<img src="AssetMarkdown/image-20230713113417200.png" alt="image-20230713113417200" style="zoom:80%;" />

核心思想：将用到的东西装载到内存中

1. 将纹理分为不同块，分块数满足2的幂次
2. 然后根据分块对纹理建立Mipmap
3. 绘制时，只将看到的纹理LOD层加载到内存

### 6.2.6	浮点数精度溢出

<img src="AssetMarkdown/image-20230713114800746.png" alt="image-20230713114800746" style="zoom:80%;" />

1. 当摄像机&地形的全局坐标很大(如1km)，而地形上的物体与地形距离很近(如0.5m)的时候，远处的地形与物体就会由于精度问题产生抖动

<img src="AssetMarkdown/image-20230713115131010.png" alt="image-20230713115131010" style="zoom:80%;" />

2. 解决方法：
   1. 将相机的位置强行设置为0，地形的位置坐标根据相机的位置设置，此时两者使用到的坐标都不会很大，就可以保证小数点后的精度了
      1. 修改前：地形位置1000010m、物体位置1000010.5m、相机位置1000000m
      2. 修改后：地形位置10m、物体位置10.5m、相机位置0m
   2. 也可以将整个大型关卡切分为不同的小关卡，每个小关卡拥有自己的全局坐标系

## 6.3	植被道路贴花等

### 6.3.1	树木渲染

<img src="AssetMarkdown/image-20230713123021648.png" alt="image-20230713123021648" style="zoom:80%;" />

### 6.3.2	装饰物渲染 Decorator

<img src="AssetMarkdown/image-20230713123446738.png" alt="image-20230713123446738" style="zoom:80%;" />

### 6.3.3	道路和贴画渲染

<img src="AssetMarkdown/image-20230713123544838.png" alt="image-20230713123544838" style="zoom:80%;" />

1. 将地形的纹理、道路的纹理、贴画的纹理全部放到Virtual Texture中，runtime的时候直接调用virtual texture即可
2. 计算的复杂度集中在bake中，runtime的时候只需要将纹理贴上去即可，开销很低

## 6.4	大气散射理论
[TOC]

# 十、物理：基础理论和算法

## 10.1	物理对象与形状

### 10.1.1	Actor

1. static actor：静态物体，不移动，不用解算
2. dynamic actor：动态物体，每一帧都需要计算其状态
3. trigger：触发器，和物理世界没有关系
4. kinematic actor：运动学物体，无视物理规则，直接由游戏逻辑控制

<img src="AssetMarkdown/image-20230727110520872.png" alt="image-20230727110520872" style="zoom:80%;" />

### 10.1.2	Actor Shapes

<img src="AssetMarkdown/image-20230727110718269.png" alt="image-20230727110718269" style="zoom:80%;" />

### 10.1.3	Shape属性

质量 Mass & 密度 Density

<img src="AssetMarkdown/image-20230727111612952.png" alt="image-20230727111612952" style="zoom:80%;" />

质心 Center of Mass

<img src="AssetMarkdown/image-20230727111727898.png" alt="image-20230727111727898" style="zoom:80%;" />

物理材质：摩擦系数 Friction、弹性系数 Restitution

<img src="AssetMarkdown/image-20230727111749362.png" alt="image-20230727111749362" style="zoom:80%;" />

## 10.2	力与运动

### 10.2.1	力的种类

Force：有一定持续时间的力，如重力、拉力、摩擦力

<img src="AssetMarkdown/image-20230727114748641.png" alt="image-20230727114748641" style="zoom:80%;" />

Impulse：冲量

<img src="AssetMarkdown/image-20230727114857546.png" alt="image-20230727114857546" style="zoom:80%;" />

### 10.2.2	移动

显式欧拉法：用当前的力&速度计算位移

1. 优点：容易计算
2. 缺点：能量不守恒

<img src="AssetMarkdown/image-20230727143630198.png" alt="image-20230727143630198" style="zoom:80%;" />

隐式欧拉法：用未来的力&速度计算位移

1. 优点：能量会衰减，从而保证计算是稳定的，衰减很小时可以被视为转化为热能
2. 缺点：如果力是取决于位置的，那么在位置不确定的情况下，无法知道未来的力

<img src="AssetMarkdown/image-20230727143510570.png" alt="image-20230727143510570" style="zoom:80%;" />

半隐式欧拉法：用当前的力、未来的速度计算位移

1. 优点：更加稳定，并且容易计算
2. 缺点：积分出来的周期会比实际的周期长一点，导致有一定的相位差

<img src="AssetMarkdown/image-20230727144235099.png" alt="image-20230727144235099" style="zoom:80%;" />

## 10.3	刚体动力学

### 10.3.1	质点动力学

<img src="AssetMarkdown/image-20230727144551982.png" alt="image-20230727144551982" style="zoom:80%;" />

### 10.3.2	基础概念

<img src="AssetMarkdown/image-20230727144854761.png" alt="image-20230727144854761" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727145512765.png" alt="image-20230727145512765" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727145535306.png" alt="image-20230727145535306" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727145737642.png" alt="image-20230727145737642" style="zoom: 80%;" />

<img src="AssetMarkdown/image-20230727145758977.png" alt="image-20230727145758977" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727150006906.png" alt="image-20230727150006906" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727150041602.png" alt="image-20230727150041602" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727150231290.png" alt="image-20230727150231290" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727150318355.png" alt="image-20230727150318355" style="zoom:80%;" />

## 10.4	碰撞检测

### 10.4.1	两个阶段

1. Broad Phase：使用AABB包围盒，快速筛除一些不会碰撞的物体
2. Narrow Phase：精确判断是否能够碰撞，生成碰撞信息

<img src="AssetMarkdown/image-20230727151246689.png" alt="image-20230727151246689" style="zoom:80%;" />

### 10.4.2	Broad Phase

#### 10.4.2.1	BVH树

<img src="AssetMarkdown/image-20230727151333377.png" alt="image-20230727151333377" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727151359255.png" alt="image-20230727151359255" style="zoom:80%;" />

#### 10.4.2.2	Sort and Sweep

对于AABB包围盒来说：

1. 将每个包围盒按照x轴上的两个边界排序
2. 如果在轴上分离，则一定无法碰撞
3. 如果在轴上交错，则可能碰撞，此时计算y轴是否交错
4. 只有两个轴上都交错，才会碰撞

<img src="AssetMarkdown/image-20230727151415157.png" alt="image-20230727151415157" style="zoom:80%;" />

更新时：

1. 相当于在一个已经排好序的数组中，更新某个数的位置，效率很高

<img src="AssetMarkdown/image-20230727151708077.png" alt="image-20230727151708077" style="zoom:80%;" />

### 10.4.3	Narrow Phase

1. 准确检测碰撞
2. 生成碰撞信息
   1. 碰撞采样：生成碰撞点的集合
   2. 碰撞法线
   3. 穿透深度

<img src="AssetMarkdown/image-20230727171236961.png" alt="image-20230727171236961" style="zoom:80%;" />

#### 10.4.3.1	基础图形碰撞检测

<img src="AssetMarkdown/image-20230727172955545.png" alt="image-20230727172955545" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727173031040.png" alt="image-20230727173031040" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727175222136.png" alt="image-20230727175222136" style="zoom:80%;" />

#### 10.4.3.2	Minkowski算法

<img src="AssetMarkdown/image-20230727175329180.png" alt="image-20230727175329180" style="zoom:80%;" />

##### 10.4.3.2.1	Minkowski和

1. A为一个点：相当于B加上了A的位移
2. A为线段：相当于B加上A的位移后，沿A的方向和长度整体移动
3. A为三角形：相当于B加上A的位移后，沿A的轮廓整体移动
4. 两个凸包的闵可夫和 = 对应顶点的闵可夫和

| <img src="AssetMarkdown/image-20230728104958801.png" alt="image-20230728104958801" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728105035389.png" alt="image-20230728105035389" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728105050063.png" alt="image-20230728105050063" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728105104420.png" alt="image-20230728105104420" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ | ------------------------------------------------------------ |

##### 10.4.3.2.2	Minkowski差

1. 将被减数变为它的负数，转化为Minkowski和

<img src="AssetMarkdown/image-20230728102422657.png" alt="image-20230728102422657" style="zoom:80%;" />

##### 10.4.3.2.3	Minkowski差 & 原点

1. 如果两个凸包有交点，那么Minkowski差一定包含原点

<img src="AssetMarkdown/image-20230728102534497.png" alt="image-20230728102534497" style="zoom:80%;" />

##### 10.4.3.2.4	GJK算法

1. 随机选取一个方向，在该方向的两端找到沿该方向最远的两个点AB，这两个点相减一定是结果的一个顶点C
2. 以OC为新的方向，再选择两个点相减，得到顶点D
3. 以CD的垂线方向，选择两个点相减，得到顶点E
4. 判断原点是否在三角形CDE中
   1. 如果在，则说明凸包包含原点
   2. 如果不在，则以离原点最远的那条边的垂线方向，选择两个点相减，得到顶点F，判断原点是否在三角形DEF中
   3. 以此类推，直到无法找到新的凸包中的顶点

| <img src="AssetMarkdown/image-20230728104002566.png" alt="image-20230728104002566" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728103858070.png" alt="image-20230728103858070" style="zoom: 50%;" /> | <img src="AssetMarkdown/image-20230728104026849.png" alt="image-20230728104026849" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |

| <img src="AssetMarkdown/image-20230728104350214.png" alt="image-20230728104350214" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728104507055.png" alt="image-20230728104507055" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |

| <img src="AssetMarkdown/image-20230728104616148.png" alt="image-20230728104616148" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728104640817.png" alt="image-20230728104640817" style="zoom:50%;" /> | <img src="AssetMarkdown/image-20230728104701180.png" alt="image-20230728104701180" style="zoom: 50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |

#### 10.4.3.3	分离轴定理 SAT：Separating Axis Theorem

1. 空间中的任意两个不相交的凸多面体，一定能找到一根轴，使得：两个凸多面体在该轴上的投影不会有交集
2. 空间中的任意两个不相交的凸多面体，以其中一个多面体的一条边为轴，能够将这两个凸多面体分离

<img src="AssetMarkdown/image-20230728105434748.png" alt="image-20230728105434748" style="zoom:80%;" />

检测算法：

1. 以A的每一条边的垂线为轴，检测B的每个顶点是否在A的另一侧
2. 以B的每一条边的垂线为轴，检测A的每个顶点是否在A的另一侧
3. 只要有一条边满足要求，那么两者就是分离的

<img src="AssetMarkdown/image-20230728110008864.png" alt="image-20230728110008864" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728110034047.png" alt="image-20230728110034047" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728111432807.png" alt="image-20230728111432807" style="zoom:80%;" />

3D中的延申：

1. 要检测A中的每一个面、B中的每一个面
2. 还需要检测A中的每一条边与B中的每一条边的叉积形成的平面

<img src="AssetMarkdown/image-20230728111731191.png" alt="image-20230728111731191" style="zoom:80%;" />

对于运动中的物体：

1. 上一次得到的分离轴，是下一次检测的第一个轴

## 10.5	碰撞解决

<img src="AssetMarkdown/image-20230728111957590.png" alt="image-20230728111957590" style="zoom:80%;" />

### 10.5.1	添加一个Penalty Force

<img src="AssetMarkdown/image-20230728112049397.png" alt="image-20230728112049397" style="zoom:80%;" />

### 10.5.2	将力学问题转化为约束问题

<img src="AssetMarkdown/image-20230728112126815.png" alt="image-20230728112126815" style="zoom:80%;" />

1. 碰撞时，给物体一个小冲量，然后求解拉格朗日约束
2. 如果不满足约束，则调整冲量，不断迭代，直到满足约束

<img src="AssetMarkdown/image-20230728112234729.png" alt="image-20230728112234729" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728112321997.png" alt="image-20230728112321997" style="zoom:80%;" />

## 10.6	场景请求

### 10.6.1	Ray Cast

<img src="AssetMarkdown/image-20230728112543030.png" alt="image-20230728112543030" style="zoom:80%;" />

1. Mutiple hits：返回所有碰撞结果
2. Closest hit：返回最近的碰撞结果
3. Any hit：随机返回一个碰撞结果

### 10.6.2	Sweep

整个物体的横扫

<img src="AssetMarkdown/image-20230728112728897.png" alt="image-20230728112728897" style="zoom:80%;" />

### 10.6.3	Overlap

判断一个形体是否与其他Actor碰撞

<img src="AssetMarkdown/image-20230728112752743.png" alt="image-20230728112752743" style="zoom:80%;" />

### 10.6.4	碰撞分组

<img src="AssetMarkdown/image-20230728112850790.png" alt="image-20230728112850790" style="zoom:80%;" />

## 10.7	效率、准确性、确定性

### 10.7.1	Island

将整个物理世界分为不同island

<img src="AssetMarkdown/image-20230728113001390.png" alt="image-20230728113001390" style="zoom:80%;" />

如果某个island稳定下来了，那么就会进入sleeping状态

<img src="AssetMarkdown/image-20230728113016423.png" alt="image-20230728113016423" style="zoom:80%;" />

### 10.7.2	CCD：Continuous Collision Detection 持续碰撞检测

当物体移动过快时，可能会出现上一帧没碰撞，下一帧直接穿过的问题

1. 可以将地面做厚
2. 进行CCD：保守估计一个安全步长，当距离过近时，需要减小步长

<img src="AssetMarkdown/image-20230728113157251.png" alt="image-20230728113157251" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728113223229.png" alt="image-20230728113223229" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728113337301.png" alt="image-20230728113337301" style="zoom:80%;" />

### 10.7.3	确定性模拟

<img src="AssetMarkdown/image-20230728113505626.png" alt="image-20230728113505626" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230728113713014.png" alt="image-20230728113713014" style="zoom:80%;" />
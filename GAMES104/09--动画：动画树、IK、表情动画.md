[TOC]

# 九、动画：动画树、IK、表情动画

## 9.1	动画混合：LERP

在不同动画内，各取一帧，进行插值

<img src="AssetMarkdown/image-20230726161349832.png" alt="image-20230726161349832" style="zoom:80%;" />

### 9.1.1	计算混合权重

<img src="AssetMarkdown/image-20230726161520179.png" alt="image-20230726161520179" style="zoom:80%;" />

### 9.1.2	对齐混合时间线

1. 将动画的时间归一化
   1. 对于走和跑的两个动画，保证：0-没有动，0.25-抬左脚，0.5-放左脚，0.75-抬右脚，1.0-放右脚

<img src="AssetMarkdown/image-20230726161637220.png" alt="image-20230726161637220" style="zoom:80%;" />

## 9.2	混合空间

### 9.2.1	1D混合空间

1. 可以有多个动画，通过一个变量进行混合
2. 并且动画切换的密度也不一定是均匀的

<img src="AssetMarkdown/image-20230726162032131.png" alt="image-20230726162032131" style="zoom:80%;" />

### 9.2.2	2D混合空间

<img src="AssetMarkdown/image-20230726162328115.png" alt="image-20230726162328115" style="zoom:80%;" />

1. Delaunay三角化：根据给定的多个顶点，生成空间的三角形划分
2. 根据速度&方向两个值，确定二维空间上的唯一点，选择临近的三个动画，通过重心坐标的方法进行插值

<img src="AssetMarkdown/image-20230726162413212.png" alt="image-20230726162413212" style="zoom:80%;" />

### 9.2.3	Skeleton Masked Blending

通过mask，控制动画影响的关节

<img src="AssetMarkdown/image-20230726162907137.png" alt="image-20230726162907137" style="zoom:80%;" />

### 9.2.4	Additive Blending

动画只影响局部关节，且只保留变化量，在原有骨骼之上添加额外的transform

<img src="AssetMarkdown/image-20230726163020077.png" alt="image-20230726163020077" style="zoom:80%;" />

叠加动画可能回调导致非正常的骨骼结果

<img src="AssetMarkdown/image-20230726163239755.png" alt="image-20230726163239755" style="zoom:80%;" />

## 9.3	动画状态机 ASM Animation State Machine

### 9.3.1	ASM的定义

ASM的节点：

1. 可以是一个动画，也可以是混合空间，还可以是动画树
2. 要求节点的产出必须是一个pose

<img src="AssetMarkdown/image-20230726163706843.png" alt="image-20230726163706843" style="zoom:80%;" />

状态过渡：

<img src="AssetMarkdown/image-20230726163926818.png" alt="image-20230726163926818" style="zoom:80%;" />

状态过渡时的Fade：

1. Smooth Transition：两个动画进行插值
2. Frozen Transition：上一个动画停止，下一个动画逐步进入

<img src="AssetMarkdown/image-20230726164019587.png" alt="image-20230726164019587" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726164219218.png" alt="image-20230726164219218" style="zoom:80%;" />

### 9.3.2	Layered ASM

分为不同层，控制角色的不同部分

<img src="AssetMarkdown/image-20230726164525801.png" alt="image-20230726164525801" style="zoom:80%;" />

## 9.4	动画混合树

### 9.4.1	混合树

<img src="AssetMarkdown/image-20230726164757665.png" alt="image-20230726164757665" style="zoom:80%;" />

### 9.4.2	混合节点

#### 9.4.2.1	LERP混合节点

二通道插值：一个权重，控制两者比例

多通道插值：通常需要自己定义动画各自的比例

<img src="AssetMarkdown/image-20230726164820353.png" alt="image-20230726164820353" style="zoom:80%;" />

#### 9.4.2.2	Additive混合节点

<img src="AssetMarkdown/image-20230726164944591.png" alt="image-20230726164944591" style="zoom:80%;" />

#### 9.4.2.3	混合树节点

叶节点：动画、混合空间、动画状态机

中间节点：LERP混合节点、Additive混合节点

<img src="AssetMarkdown/image-20230726165138287.png" alt="image-20230726165138287" style="zoom:80%;" />

### 9.4.3	混合树控制参数

1. 混合树上要暴露大量的控制参数，由Game Play控制不同节点的混合、状态机
2. 可以通过事件控制参数的改变

<img src="AssetMarkdown/image-20230726165450780.png" alt="image-20230726165450780" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726165816283.png" alt="image-20230726165816283" style="zoom:80%;" />

## 9.5	IK技术

### 9.5.1	基本概念

End-Effector：希望被移动到目标位置的末端关节

IK：给定end-effecto的期望位置，反向求解骨骼的变换

FK：给定骨骼的变化，计算end-effector的位置

<img src="AssetMarkdown/image-20230726170138434.png" alt="image-20230726170138434" style="zoom:80%;" />

### 9.5.2	Two Bones IK

1. 大腿和小腿两根骨头 => 三角形的两条边
2. 脚的位置/地面的位置 => 目标点
3. 大腿根部到目标点的距离 => 三角形的第三条边

根据三角形的三条边边长，可以唯一确定一个三角形，从而求解出大腿、小腿各自的旋转

<img src="AssetMarkdown/image-20230726170422401.png" alt="image-20230726170422401" style="zoom:80%;" />

上述算法解出的实际上是一个圆环

<img src="AssetMarkdown/image-20230726170647922.png" alt="image-20230726170647922" style="zoom:80%;" />

通过额外给定一个reference vector，确定是圆环上的哪个点

1. 通过reference vector、大腿和目标点的连线，确定一个平面
2. 平面与圆环求交，得到两个交点
3. 通过向量点乘，确定哪个点是正向的，哪个点是反向的

<img src="AssetMarkdown/image-20230726170731090.png" alt="image-20230726170731090" style="zoom:80%;" />

### 9.5.3	多关节IK计算

<img src="AssetMarkdown/image-20230726171113977.png" alt="image-20230726171113977" style="zoom:80%;" />

#### 9.5.3.1	可达性判断

<img src="AssetMarkdown/image-20230726171154553.png" alt="image-20230726171154553" style="zoom:80%;" />

#### 9.5.3.2	关节约束

<img src="AssetMarkdown/image-20230726171245185.png" alt="image-20230726171245185" style="zoom:80%;" />

#### 9.5.3.3	CCD：Cyclic Coordinate Decent

1. 将最末端的关节，向上一个关节与目标点的连线方向旋转，逐步旋转所有关节
2. 重复上述步骤，直到每一次旋转几乎不变

<img src="AssetMarkdown/image-20230726171715760.png" alt="image-20230726171715760" style="zoom:80%;" />

| <img src="AssetMarkdown/image-20230726172025542.png" alt="image-20230726172025542" style="zoom: 50%;" /> | <img src="AssetMarkdown/image-20230726172049462.png" alt="image-20230726172049462" style="zoom:50%;" /> |
| :----------------------------------------------------------: | :----------------------------------------------------------: |

#### 9.5.3.4	优化CCD

1. 旋转时不需要要求骨骼一定要到达目标位置，只需要到达一个范围即可 or 设置旋转角度上限
2. 每次迭代逐渐缩小范围

<img src="AssetMarkdown/image-20230726172307179.png" alt="image-20230726172307179" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726172453544.png" alt="image-20230726172453544" style="zoom:80%;" />

#### 9.5.3.5	FABRIK：Forward And Backward Reaching IK

Forward：

1. 从End-Effector开始，把第一个关节强行拉到目标点
2. 根据上一个关节点的原有位置，与当前关节点连一条线，将骨骼旋转到连线上
3. 骨骼的另一端即为下一个关键点的目标位置
4. 重复上述步骤，直到根节点为止
5. 此时会由于凑关键点位置，导致根节点移动，需要通过Backward解决

Backward：

1. 从根节点开始，将根节点拉回到原点
2. 依次移动对应骨骼和另一端的关节点，直到拉到End-Effector

重复Forward和Backward，直到End-Effector非常接近目标点

<img src="AssetMarkdown/image-20230726172950697.png" alt="image-20230726172950697" style="zoom:80%;" />

骨骼约束：将目标点投影到约束的平面，得到新的目标点，然后再移动骨骼

<img src="AssetMarkdown/image-20230726173401688.png" alt="image-20230726173401688" style="zoom:80%;" />

### 9.5.4	多End-Effectors

<img src="AssetMarkdown/image-20230726173555467.png" alt="image-20230726173555467" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726173636640.png" alt="image-20230726173636640" style="zoom:80%;" />

#### 9.5.4.1	Jacobian Matrix

<img src="AssetMarkdown/image-20230726173727183.png" alt="image-20230726173727183" style="zoom:80%;" />

通过雅可比矩阵，逐步逼近目标点

<img src="AssetMarkdown/image-20230726174159735.png" alt="image-20230726174159735" style="zoom:80%;" />

### 9.5.5	其他IK解法

<img src="AssetMarkdown/image-20230726174332161.png" alt="image-20230726174332161" style="zoom:80%;" />

### 9.5.6	IK的问题

1. IK会认为骨骼是没有体积的，从而导致解出的骨骼由穿插
2. IK无法预测环境
3. IK解出的解不考虑平衡重心等问题

### 9.5.7	添加IK之后的动画Pipeline

<img src="AssetMarkdown/image-20230726174830356.png" alt="image-20230726174830356" style="zoom:80%;" />

## 9.6	面部动画

### 9.6.1	表情由复杂的肌肉系统驱动

<img src="AssetMarkdown/image-20230726175017486.png" alt="image-20230726175017486" style="zoom:80%;" />

### 9.6.2	面部动作编码系统 FACS

<img src="AssetMarkdown/image-20230726175211494.png" alt="image-20230726175211494" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726175311165.png" alt="image-20230726175311165" style="zoom:80%;" />

### 9.6.3	28个核心AU

<img src="AssetMarkdown/image-20230726175719857.png" alt="image-20230726175719857" style="zoom:80%;" />

### 9.6.4	关键姿势混合

<img src="AssetMarkdown/image-20230726175742143.png" alt="image-20230726175742143" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230726175818590.png" alt="image-20230726175818590" style="zoom:80%;" />

实际存储的是某一个表情对应中性表情的offset

<img src="AssetMarkdown/image-20230726175907342.png" alt="image-20230726175907342" style="zoom:80%;" />

### 9.6.5	UV Texture Facial Animation

用纹理表达面部表情

<img src="AssetMarkdown/image-20230727100531316.png" alt="image-20230727100531316" style="zoom:80%;" />

### 9.6.6	Muscle Model Animation

通过46个实际肌肉控制面部运动

<img src="AssetMarkdown/image-20230727100640384.png" alt="image-20230727100640384" style="zoom:80%;" />

## 9.7	动画重定向

### 9.7.1	相关术语 Terminology

<img src="AssetMarkdown/image-20230727101019327.png" alt="image-20230727101019327" style="zoom:80%;" />

### 9.7.2	重定向的方法

1. 骨骼一根对一根，忽略位移项

   <img src="AssetMarkdown/image-20230727101219102.png" alt="image-20230727101219102" style="zoom:80%;" />

2. 应用每一帧相对binding pose的位移，而不是绝对值

   <img src="AssetMarkdown/image-20230727101307534.png" alt="image-20230727101307534" style="zoom:80%;" />

3. 把source character的

   1. 旋转动画：直接应用到target character上
   2. 平移动画：考虑骨骼的相对长度，等比例放缩
   3. 缩放动画：直接应用到target character上

   <img src="AssetMarkdown/image-20230727101506030.png" alt="image-20230727101506030" style="zoom:80%;" />

4. 通过Pelvis高度对齐运动

   1. 通过最初的腰眼离地的距离，等比例缩放运动速度

   <img src="AssetMarkdown/image-20230727101720649.png" alt="image-20230727101720649" style="zoom:80%;" />

5. 重定向之后，通过IK将脚锁死在地上

   <img src="AssetMarkdown/image-20230727101938145.png" alt="image-20230727101938145" style="zoom:80%;" />

6. 通常是使用离线算法，进行重定向的计算

### 9.7.3	不同骨骼结构之间的重定向

1. 找到不同骨骼结构之间，对应的骨骼
2. 将骨骼归一化到[0, 1]之间，然后进行插值

<img src="AssetMarkdown/image-20230727102206721.png" alt="image-20230727102206721" style="zoom:80%;" />

### 9.7.4	未解决的问题

1. 骨骼穿插问题
2. 由于骨骼大小不一样，导致的效果不佳，如鼓掌等语义动作
3. 目标角色的平衡

<img src="AssetMarkdown/image-20230727102448557.png" alt="image-20230727102448557" style="zoom:80%;" />

### 9.7.5	Morph Animation重定向

1. 不同face使用相同的拓扑结构
2. 存储顶点的相对位移
3. 应用重定向后，强制将某些顶点移动到目标位置，然后用拉普拉斯算子计算剩下的顶点

<img src="AssetMarkdown/image-20230727102755696.png" alt="image-20230727102755696" style="zoom:80%;" />

<img src="AssetMarkdown/image-20230727102852037.png" alt="image-20230727102852037" style="zoom:80%;" />